setwd('/media/areshenk/Storage/Repositories/MSMVSampEn')
dat = matrix(rnorm(3000), nrow = 3)
Rcpp::sourceCpp('src/embed.cpp')
install.packages('Rcpp')
install.packages("Rcpp")
install.packages("RcppArmadillo")
library(Rcpp)
library(RcppArmadillo)
Rcpp::sourceCpp('src/embed.cpp')
d = read_dcf('src/embed.cpp')
Rcpp::sourceCpp('src/embed.cpp')
Rcpp::sourceCpp('src/similarityCount.cpp')
MVSampEn = function(mat, M, tau, r, scaleMat = TRUE){
# Returns the multivariate entropy of a time series. Function accepts
# five arguments:
#   mat: a pxn matrix containing a p-variate time series
#   M: A vector of length p specifying the embedding dimension
#   tau: A vector of length p specifying the time lag parameter
#   r: The similarity threshold
#   scaleMat: Whether or not to scale the rows of the time series
# Error Handling
if (!is.matrix(mat))
stop('mat must be a matrix')
if (!(is.numeric(M) && length(M) == dim(mat)[1]))
stop('M must be a vector of length equals to the rows of mat')
if (any(M <= 0))
stop('M must be positive')
if (!(is.numeric(tau) && length(tau) == dim(mat)[1]))
stop('M must be a vector of length equals to the rows of mat')
if (any(tau <= 0))
stop('tau must be positive')
# Scale data if necessary
if (scaleMat)
mat = t(scale(t(mat)))
#
nVariables = dim(mat)[1]
nSamples = dim(mat)[2]
MMax = max(M)
tauMax = max(tau)
nn = MMax * tauMax
# Count the number of match templates of length m closed within
# the tolerance r.
N = nSamples - nn
A = embed(mat, M, tau)
v1 = similarityCount(A, r)
p1 = 2 * v1 / (N * (N-1))
# Error checking
if (p1 == 0)
stop('Zero matches found for p1. Consider increasing the tolerance r')
I = diag(rep(1, nVariables))
M2 = matrix(rep(M, nVariables), nrow = nVariables, byrow = T) + I
B = NULL
for (i in 1:nVariables){
dummy = embed(mat, M2[i,], tau)
B = rbind(B, dummy)
}
v2 = similarityCount(B, r)
p2 = 2 * v2 / (nVariables * N * (nVariables * N-1))
# Error checking
if (p2 == 0)
stop('Zero matches found for p2. Consider increasing the tolerance r')
return(log(p1) - log(p2))
}
test = MVSampEn(dat, c(1,1,1), c(1,1,1), r = 1)
coarsegrainMultivariate = function(mat, eps){
# Function coarsegrains a multivariate time series given by a
# pxn matrix mat (where p is the number of variables)
return(t(apply(mat, 1, function(x) coarsegrainUnivariate(x, eps))))
}
coarsegrainUnivariate = function(x, eps){
# Function coarsegrains a vector x by partitioning it into bins of size eps
# and computing the average within the bins.
n <- length(x)
r <- n %% eps
return(colMeans(matrix(x[1:(n-r)], nrow = eps)))
}
MSMVSampEn = function(mat, M, tau, r, eps, scaleMat = TRUE){
# Wrapper for entropy.R that allows the user to specify an integer scale
# parameter eps. The time series is coarsegrained, and then the entropy is
# computed for the specified time scale.
#
# Function accepts six arguments:
#   mat: a pxn matrix containing a p-variate time series
#   M: A vector of length p specifying the embedding dimension
#   tau: A vector of length p specifying the time lag parameter
#   r: The similarity threshold
#   eps: An integer specifying the time scale
#   scaleMat: Whether or not to scale the rows of the time series
X = coarsegrainMultivariate(mat, eps)
return(MVSampEn(X, M, tau, r, scaleMat))
}
test = MSVSampEn(dat, c(1,1,1), c(1,1,1), r = 1, eps = 1)
MSMVSampEn = function(mat, M, tau, r, eps, scaleMat = TRUE){
# Wrapper for entropy.R that allows the user to specify an integer scale
# parameter eps. The time series is coarsegrained, and then the entropy is
# computed for the specified time scale.
#
# Function accepts six arguments:
#   mat:      A pxn matrix containing a p-variate time series
#   M:        A vector of length p specifying the embedding dimension
#   tau:      A vector of length p specifying the time lag parameter
#   r:        The similarity threshold
#   eps:      An integer specifying the time scale
#   scaleMat: Whether or not to scale the rows of the time series
X = coarsegrainMultivariate(mat, eps)
return(MVSampEn(X, M, tau, r, scaleMat))
}
test = MSVSampEn(dat, c(1,1,1), c(1,1,1), r = 1, eps = 1)
test = MSMVSampEn(dat, c(1,1,1), c(1,1,1), r = 1, eps = 1)
MSMVSampEn(dat, c(2,2,2), c(1,1,1), r = .15, eps = 1)
MSMVSampEn(dat, c(2,2,2), c(1,1,1), r = 1, eps = 1)
MSMVSampEn(dat, c(2,2,2), c(1,1,1), r = .8, eps = 1)
MSMVSampEn(dat, c(2,2,2), c(1,1,1), r = .5, eps = 1)
MSMVSampEn(dat, c(2,2,2), c(1,1,1), r = .5, eps = 5)
install.packages('Roxygen')
install.packages('roxygen2')
